{"mappings":"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","sources":["lib/index.js","lib/ahash.js","lib/imageUtils.js","lib/hash.js","lib/dhash.js","lib/phash.js","lib/whash.js","lib/cropResistantHash.js","lib/blur.js"],"sourcesContent":["import {ahash} from \"./ahash.js\";\nimport {dhash} from \"./dhash.js\";\nimport {phash} from \"./phash.js\";\nimport {whash} from \"./whash.js\";\nimport {ImageHash} from \"./hash.js\";\nimport {cropResistantHash} from \"./cropResistantHash.js\";\n\n\nexport {\n    ahash,\n    dhash,\n    phash,\n    whash,\n    cropResistantHash,\n    ImageHash\n}\n\nif (typeof window !== 'undefined') {\n    window.ahash = ahash;\n    window.dhash = dhash;\n    window.phash = phash;\n    window.whash = whash;\n    window.cropResistantHash = cropResistantHash;\n    window.ImageHash = ImageHash;\n}\n\n","import {canvasUtil, grayScaleConverter} from \"./imageUtils.js\";\nimport {ImageHash} from \"./hash.js\";\n\n\n/**\n * @param image {Image}\n * @param size {number}\n */\nexport async function ahash(image, size = 8) {\n    const pixels = grayScaleConverter.convert(await canvasUtil.resizeImageAndGetData(image, size, size));\n\n    const hash = new Uint8ClampedArray(size * size);\n\n    let sum = 0;\n    for (let i = 0; i < pixels.length; i++) {\n        sum += pixels[i];\n    }\n    const avg = sum / pixels.length;\n\n    for (let i = 0; i < pixels.length; i++) {\n        hash[i] = pixels[i] > avg;\n    }\n\n    return new ImageHash(hash);\n}","import {createCanvas} from \"canvas\";\nimport Pica from \"pica/index.js\";\n\n/**\n * @typedef {{x: number, y: number}} Tuple\n */\n\nclass CanvasUtil {\n\n    /**\n     * @param image {Image|HTMLImageElement}\n     * @param width {number}\n     * @param height {number}\n     * @param options {{\n     *     sx: {number},\n     *     sy: {number},\n     *     sw: {number},\n     *     sh: {number},\n     * }}\n     * @return {Uint8ClampedArray}\n     */\n    async resizeImageAndGetData(image, width, height, options = {}) {\n        let canvas = await this.resizeImage(image, width, height, options);\n\n        const ctx = canvas.getContext(\"2d\");\n        return ctx.getImageData(0, 0, width, height).data;\n    }\n\n    async resizeImage(image, width, height, options) {\n        const {sx, sy, sw, sh} = options;\n\n        let fromCanvas = this.getImageCanvas(image, sx, sy, sw, sh);\n        let toCanvas;\n        let pica;\n\n        if (typeof window === \"undefined\") {\n            // This is not a browser, use the canvas package\n            toCanvas = createCanvas(width, height);\n            toCanvas.width = width;\n            toCanvas.height = height;\n\n            // Trick pica into thinking that this is a normal HTML cavas\n            fromCanvas[Symbol.toStringTag] = \"HTMLCanvasElement\";\n\n            pica = new Pica({\n                tile: 1024,\n                concurrency: 1,\n                features: [\"js\"],\n                idle: 2000,\n                createCanvas\n            });\n        } else {\n            function browserCreateCanvas(width, height) {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                return canvas;\n            }\n\n            pica = new Pica({\n                tile: 1024,\n                concurrency: 1,\n                features: [\"js\", \"wasm\"], // Disable web workers & cib\n                idle: 2000,\n                browserCreateCanvas\n            });\n\n            toCanvas = browserCreateCanvas(width, height);\n        }\n\n        await pica.resize(fromCanvas, toCanvas);\n\n        return toCanvas;\n    }\n\n    getImageCanvas(image, sx, sy, sw, sh) {\n\n        if (Object.prototype.toString.call(image) === \"[object HTMLCanvasElement]\" && sx === undefined) {\n            return image;\n        }\n\n        const canvas = (typeof window === \"undefined\")\n            ? createCanvas(sw || image.width, sh || image.height)\n            : document.createElement(\"canvas\");\n\n        canvas.width = image.naturalWidth || sw;\n        canvas.height = image.naturalHeight || sh;\n\n        const ctx = canvas.getContext(\"2d\");\n\n        if (sx !== undefined) {\n            const sCtx = image.getContext(\"2d\");\n            const imageData = sCtx.getImageData(sx, sy, sw, sh);\n            canvas[Symbol.toStringTag] = \"HTMLCanvasElement\";\n\n            ctx.putImageData(imageData, 0, 0);\n        } else {\n            ctx.drawImage(image, 0, 0);\n        }\n\n        return canvas;\n    }\n    \n}\n\nexport const canvasUtil = new CanvasUtil();\n\nclass GrayScaleConverter {\n\n    /**\n     *\n     * RGBA -> L (ITU-R 601-2 luma transform)\n     *\n     * @param imgData {Uint8ClampedArray}\n     */\n    convert(imgData) {\n        const arr = new Uint8ClampedArray(imgData.length / 4);\n\n        for (let i = 0; i < imgData.length; i += 4) {\n            arr[i>>2] = Math.round((imgData[i] * 299 / 1000 + imgData[i + 1] * 587 / 1000 + imgData[i + 2] * 114 / 1000))\n        }\n\n        return arr;\n    }\n}\n\nexport const grayScaleConverter = new GrayScaleConverter()\n","export class ImageHash {\n\n    binArray;\n\n    /**\n     * @param binArray {Uint8ClampedArray}\n     */\n    constructor(binArray) {\n        this.binArray = binArray;\n    }\n\n    static fromBase64(s) {\n        const buf = atob(s);\n        const arr = new Uint8ClampedArray(buf.length * 8);\n\n        for (let i = 0; i < buf.length; i++) {\n            const c = buf.charCodeAt(i);\n            arr[i * 8] = (c & 0x01);\n            arr[i * 8 + 1] = (c & 0x02) >> 1;\n            arr[i * 8 + 2] = (c & 0x04) >> 2;\n            arr[i * 8 + 3] = (c & 0x08) >> 3;\n            arr[i * 8 + 4] = (c & 0x10) >> 4;\n            arr[i * 8 + 5] = (c & 0x20) >> 5;\n            arr[i * 8 + 6] = (c & 0x40) >> 6;\n            arr[i * 8 + 7] = (c & 0x80) >> 7;\n        }\n\n        return new ImageHash(arr);\n    }\n\n    static fromHexStringReversed(s) {\n        if (s.length % 2 !== 0) {\n            throw Error(\"hex string length must be a multiple of 2\");\n        }\n        const arr = new Uint8ClampedArray(s.length * 4);\n\n        for (let i = 0; i < s.length; i += 2) {\n            const c = Number.parseInt(s.slice(i, i + 2), 16);\n\n            if (Number.isNaN(c)) {\n                throw Error(\"Invalid hex string\");\n            }\n\n            arr[i * 4] = (c & 0x80) >> 7;\n            arr[i * 4 + 1] = (c & 0x40) >> 6;\n            arr[i * 4 + 2] = (c & 0x20) >> 5;\n            arr[i * 4 + 3] = (c & 0x10) >> 4;\n            arr[i * 4 + 4] = (c & 0x08) >> 3;\n            arr[i * 4 + 5] = (c & 0x04) >> 2;\n            arr[i * 4 + 6] = (c & 0x02) >> 1;\n            arr[i * 4 + 7] = (c & 0x01);\n        }\n\n        return new ImageHash(arr);\n    }\n\n    static fromHexString(s) {\n        if (s.length % 2 !== 0) {\n            throw Error(\"hex string length must be a multiple of 2\");\n        }\n        const arr = new Uint8ClampedArray(s.length * 4);\n\n        for (let i = 0; i < s.length; i += 2) {\n            const c = Number.parseInt(s.slice(i, i + 2), 16);\n\n            if (Number.isNaN(c)) {\n                throw Error(\"Invalid hex string\");\n            }\n\n            arr[i * 4] = (c & 0x01);\n            arr[i * 4 + 1] = (c & 0x02) >> 1;\n            arr[i * 4 + 2] = (c & 0x04) >> 2;\n            arr[i * 4 + 3] = (c & 0x08) >> 3;\n            arr[i * 4 + 4] = (c & 0x10) >> 4;\n            arr[i * 4 + 5] = (c & 0x20) >> 5;\n            arr[i * 4 + 6] = (c & 0x40) >> 6;\n            arr[i * 4 + 7] = (c & 0x80) >> 7;\n        }\n\n        return new ImageHash(arr);\n    }\n\n    toHexStringReversed() {\n        let str = \"\";\n\n        for (let i = 0; i < this.binArray.length; i += 8) {\n            const c =\n                this.binArray[i] << 7 |\n                this.binArray[i + 1] << 6 |\n                this.binArray[i + 2] << 5 |\n                this.binArray[i + 3] << 4 |\n                this.binArray[i + 4] << 3 |\n                this.binArray[i + 5] << 2 |\n                this.binArray[i + 6] << 1 |\n                this.binArray[i + 7];\n\n            str += c.toString(16).padStart(2, \"0\");\n        }\n\n        return str;\n    }\n\n    toHexString() {\n        let str = \"\";\n\n        for (let i = 0; i < this.binArray.length; i += 8) {\n            const c =\n                this.binArray[i] |\n                this.binArray[i + 1] << 1 |\n                this.binArray[i + 2] << 2 |\n                this.binArray[i + 3] << 3 |\n                this.binArray[i + 4] << 4 |\n                this.binArray[i + 5] << 5 |\n                this.binArray[i + 6] << 6 |\n                this.binArray[i + 7] << 7;\n\n            str += c.toString(16).padStart(2, \"0\");\n        }\n\n        return str;\n    }\n\n    toBase64() {\n        let buf = [];\n\n        for (let i = 0; i < this.binArray.length; i += 8) {\n            buf.push(this.binArray[i] |\n                this.binArray[i + 1] << 1 |\n                this.binArray[i + 2] << 2 |\n                this.binArray[i + 3] << 3 |\n                this.binArray[i + 4] << 4 |\n                this.binArray[i + 5] << 5 |\n                this.binArray[i + 6] << 6 |\n                this.binArray[i + 7] << 7)\n        }\n\n        return btoa(String.fromCharCode(...new Uint8Array(buf)));\n    }\n\n    /**\n     * @param hash {ImageHash}\n     * @returns number\n     */\n    hammingDistance(hash) {\n        if (hash.binArray.length !== this.binArray.length) {\n            throw new Error(\"Cannot compare two ImageHash instances of different sizes\");\n        }\n\n        let distance = 0;\n        for (let i = 0; i < this.binArray.length; i++) {\n            if (this.binArray[i] !== hash.binArray[i]) {\n                distance += 1;\n            }\n        }\n\n        return distance;\n    }\n}\n\nexport class ImageMultiHash {\n\n    constructor(hashes) {\n        this.segmentHashes = hashes;\n    }\n\n    toJSON() {\n        return this.segmentHashes.map(h => h.toHexString());\n    }\n\n    static fromJSON(json) {\n        return new ImageMultiHash(json.map(s => ImageHash.fromHexString(s)));\n    }\n\n    /**\n     * @param hash {ImageMultiHash}\n     * @param hammingCutoff {number}\n     * @return {sum: number, num: number}\n     */\n    hashDiff(hash, hammingCutoff) {\n        let sum = 0;\n        let num = 0;\n\n        for (let i = 0; i < hash.segmentHashes.length; i++) {\n\n            const distances = [];\n\n            for (let j = 0; j < this.segmentHashes.length; j++) {\n                distances.push(hash.segmentHashes[i].hammingDistance(this.segmentHashes[j]));\n            }\n\n            const minDistance = Math.min(...distances);\n            if (minDistance <= hammingCutoff) {\n                sum += minDistance;\n                num += 1;\n            }\n        }\n\n        return {num, sum};\n    }\n}","import {canvasUtil, grayScaleConverter} from \"./imageUtils.js\";\nimport {ImageHash} from \"./hash.js\";\n\n/**\n * @param image {Image}\n * @param size {number}\n */\nexport async function dhash(image, size = 8) {\n\n    const pixels = grayScaleConverter.convert(await canvasUtil.resizeImageAndGetData(image, size + 1, size));\n\n    const hash = new Uint8ClampedArray(size * size);\n    const nRows = size;\n    const nCols = size + 1;\n\n    let offset = 0;\n    for (let i = 0; i < nRows; i++) {\n        for (let j = 1; j < nCols; j++) {\n            hash[offset++] = pixels[i * nCols + j] > pixels[i * nCols + j - 1];\n        }\n    }\n\n    return new ImageHash(hash);\n}","import {canvasUtil, grayScaleConverter} from \"./imageUtils.js\";\nimport {ImageHash} from \"./hash.js\";\n\nconst cosCache = {};\n\nfunction precomputeCos(L) {\n    if (L in cosCache) {\n        return cosCache[L];\n    }\n\n    const piOver2L = Math.PI / (2 * L)\n\n    const cos = {};\n\n    for (let u = 0; u < L; u++) {\n        const uTimesPiOver2L = u * piOver2L;\n        for (let x = 0; x < L; x++) {\n            cos[(u << 8) + x] = Math.cos((2 * x + 1) * uTimesPiOver2L);\n        }\n    }\n\n    cosCache[L] = cos;\n\n    return cos;\n}\n\n/**\n * 2D DCT-II\n * @param matrix Must be a square matrix\n * @return {Array}\n */\nfunction dctTransform(matrix) {\n\n    const L = Math.round(Math.sqrt(matrix.length));\n\n    const cos = precomputeCos(L);\n    const dct = new Array(L * L);\n\n    let _u, _v, sum;\n\n    for (let u = 0; u < L; u++) {\n        for (let v = 0; v < L; v++) {\n            sum = 0;\n\n            _u = u << 8;\n            _v = v << 8;\n\n            for (let x = 0; x < L; x++) {\n                for (let y = 0; y < L; y++) {\n                    sum += matrix[x * L + y] * cos[_u + x] * cos[_v + y];\n                }\n            }\n\n            dct[u * L + v] = sum;\n        }\n    }\n\n    return dct\n}\n\n\nfunction median(values) {\n    values.sort((a, b) => a - b);\n    return values[Math.floor(values.length / 2)];\n}\n\n/**\n * @param image {Image}\n * @param size {number}\n * @param highFrequencyFactor {number}\n */\nexport async function phash(image, size = 8, highFrequencyFactor = 4) {\n    const imageSize = size * highFrequencyFactor;\n\n    const pixels = grayScaleConverter.convert(await canvasUtil.resizeImageAndGetData(image, imageSize, imageSize));\n\n    const dctOut = dctTransform(pixels);\n\n    const dctLowFreq = new Float64Array(size * size)\n    const sorted = new Float64Array(size * size)\n\n    let ptrLow = 0;\n    let ptr = 0;\n    for (let i = 0; i < size; i++) {\n        for (let j = 0; j < size; j++) {\n            dctLowFreq[ptrLow] = dctOut[ptr];\n            sorted[ptrLow] = dctOut[ptr];\n            ptrLow += 1;\n            ptr += 1;\n        }\n        ptr += imageSize - size;\n    }\n\n    let sum = 0;\n    for (let i = 0; i < dctLowFreq.length; i++) {\n        sum += dctLowFreq[i];\n    }\n    const med = median(sorted);\n\n    const hash = new Uint8ClampedArray(size * size);\n\n    for (let i = 0; i < hash.length; ++i) {\n        hash[i] = dctLowFreq[i] > med;\n    }\n\n    return new ImageHash(hash);\n}","import {Image} from \"canvas\";\nimport {canvasUtil, grayScaleConverter} from \"./imageUtils.js\";\nimport {ImageHash} from \"./hash.js\";\n\nconst HaarWavelet = [\n    1 / Math.SQRT2,\n    1 / Math.SQRT2\n];\n\nfunction waveletFromScalingNumbers(scalingNumbers) {\n\n    const waveletNumbers = scalingNumbers\n        .slice()\n        .reverse()\n        .map((value, index) => (index % 2 === 0) ? value : -value);\n\n    return {\n        dec: {\n            low: scalingNumbers.slice(),\n            high: waveletNumbers.slice(),\n        },\n        rec: {\n            low: scalingNumbers.slice(),\n            high: waveletNumbers.slice()\n        },\n    };\n}\n\nconst HaarBasis = waveletFromScalingNumbers(HaarWavelet);\n\nfunction getBasis(wavelet) {\n    if (wavelet === \"haar\") {\n        return HaarBasis;\n    }\n\n    throw new Error(\"Invalid wavelet\");\n}\n\nfunction dot(a, b) {\n    /* Calculate dot product. */\n    return a.reduce((dot, value, index) => dot + value * b[index], 0);\n}\n\nfunction add(a, b) {\n    /* Calculate element-wise sum. */\n    return a.map((value, index) => value + b[index]);\n}\n\nfunction mulScalar(scalar, array) {\n    return array.map(value => scalar * value);\n}\n\n\nfunction dwt(data, wavelet) {\n    const waveletBasis = getBasis(wavelet);\n    const filters = waveletBasis.dec;\n    const filterLength = filters.low.length;\n\n    let approx = [];\n    let detail = [];\n\n    /* Calculate coefficients. */\n    for (let offset = 0; offset + filterLength <= data.length; offset += 2) {\n        const values = data.slice(offset, offset + filterLength);\n\n        approx.push(dot(values, filters.low));\n        detail.push(dot(values, filters.high));\n    }\n\n    return [approx, detail];\n}\n\nfunction idwt(approx, detail, waveletBasis) {\n    const filters = waveletBasis.rec;\n    const filterLength = filters.low.length;\n\n    /* Initialize transform. */\n    const coeffLength = approx.length;\n    let pad = new Array(filterLength + (coeffLength - 1) * 2);\n    pad.fill(0);\n\n    /* Perform inverse Discrete Wavelet Transform. */\n    for (let i = 0; i < coeffLength; i++) {\n        const offset = 2 * i;\n\n        /* Calculate values. */\n        let values = pad.slice(offset, offset + filterLength);\n        values = add(values, mulScalar(approx[i], filters.low));\n        values = add(values, mulScalar(detail[i], filters.high));\n\n        /* Update values. */\n        pad = pad\n            .slice(0, offset)\n            .concat(values)\n            .concat(pad.slice(offset + values.length));\n    }\n\n    /* Remove padding. */\n    return pad.slice(filterLength - 2, pad.length - (filterLength - 2));\n}\n\n\nfunction wavedec(data, wavelet, level) {\n    /*  Initialize transform. */\n    let coeffs = [];\n    let approx = data.slice();\n\n    /* Transform. */\n    for (let i = 0; i < level; i++) {\n        /* Perform single level transform. */\n        const approxDetail = dwt(approx, wavelet);\n        approx = approxDetail[0];\n\n        /* Prepend detail coefficients. */\n        coeffs.unshift(approxDetail[1].slice());\n    }\n\n    /* Prepend last approximation. */\n    coeffs.unshift(approx.slice());\n\n    return coeffs;\n}\n\nfunction waverec(coeffs, wavelet) {\n    wavelet = getBasis(wavelet)\n\n    let approx = coeffs[0];\n\n    for (let i = 1; i < coeffs.length; i++) {\n        const detail = coeffs[i];\n\n        if (approx.length === detail.length + 1) {\n            approx = approx.slice(0, approx.length - 1);\n        }\n\n        approx = idwt(approx, detail, wavelet);\n    }\n\n    return approx.slice();\n}\n\n\nfunction median(values) {\n    values.sort((a, b) => a - b);\n    return values[Math.floor(values.length / 2)];\n}\n\nfunction wavedec2(data, wavelet, level) {\n    const L = Math.round(Math.sqrt(data.length));\n\n    const rows = new Array(L);\n\n    for (let y = 0; y < L; y++) {\n        const row = new Array(L);\n\n        for (let x = 0; x < L; x++) {\n            row[x] = data[y * L + x];\n        }\n\n        rows[y] = row;\n    }\n\n    const cols = new Array(L);\n    for (let i = 0; i < L; i++) {\n        cols[i] = new Array(L);\n    }\n\n    // Rows\n    for (let y = 0; y < L; y++) {\n        const coeffs = wavedec(rows[y], \"haar\", level).flat();\n        for (let x = 0; x < L; x++) {\n            cols[x][y] = coeffs[x];\n        }\n    }\n\n    const result = new Array(L * L);\n\n    // Cols\n    for (let x = 0; x < L; x++) {\n        const coeffs = wavedec(cols[x], \"haar\", level).flat();\n\n        for (let y = 0; y < L; y++) {\n            result[y * L + x] = coeffs[y];\n        }\n    }\n\n    return result;\n}\n\nfunction unflatten(data, level) {\n    const result = [];\n\n    const sizes = [];\n\n    let n = data.length;\n    for (let i = 0; i < level; i++) {\n        n /= 2;\n        sizes.unshift(n)\n    }\n    sizes.unshift(n);\n\n    let cur = 0;\n    for (let i = 0; i < sizes.length; i++) {\n        result.push(data.slice(cur, cur + sizes[i]));\n        cur += sizes[i];\n    }\n\n    return result;\n}\n\nfunction waverec2(data, wavelet, level) {\n    const L = Math.round(Math.sqrt(data.length));\n\n    const cols = new Array(L);\n\n    for (let x = 0; x < L; x++) {\n        const col = new Array(L);\n\n        for (let y = 0; y < L; y++) {\n            col[y] = data[y * L + x];\n        }\n\n        cols[x] = col;\n    }\n\n    const rows = new Array(L);\n    for (let i = 0; i < L; i++) {\n        rows[i] = new Array(L);\n    }\n\n    // Cols\n    for (let x = 0; x < L; x++) {\n        const rec = waverec(unflatten(cols[x], level), \"haar\")\n\n        for (let y = 0; y < L; y++) {\n            rows[y][x] = rec[y];\n        }\n    }\n\n    const result = new Array(L * L);\n\n    // Rows\n    for (let y = 0; y < L; y++) {\n        const rec = waverec(unflatten(rows[y], level), \"haar\");\n        for (let x = 0; x < L; x++) {\n            result[y * L + x] = rec[x];\n        }\n    }\n\n    return result;\n}\n\n/**\n * @param image {Image}\n * @param size {number}\n * @param removeMaxHaarLL {boolean}\n */\nexport async function whash(image, size = 8, removeMaxHaarLL = true) {\n\n    const imageNaturalScale = 2 ** Math.floor(Math.log2(Math.min(image.naturalWidth, image.naturalHeight)))\n    const imageSize = Math.max(imageNaturalScale, size)\n\n    const llMaxLevel = Math.floor(Math.log2(imageSize))\n\n    const level = Math.floor(Math.log2(size))\n    const dwtLevel = llMaxLevel - level\n\n    const pixels = grayScaleConverter.convert(await canvasUtil.resizeImageAndGetData(image, imageSize, imageSize));\n    let data = new Array(pixels.length);\n\n    for (let i = 0; i < pixels.length; i++) {\n        data[i] = pixels[i] / 255;\n    }\n\n    if (removeMaxHaarLL) {\n        const coeffs = wavedec2(data, \"haar\", llMaxLevel);\n        coeffs[0] = 0;\n        data = waverec2(coeffs, \"haar\", llMaxLevel)\n    }\n\n    const result = wavedec2(data, \"haar\", dwtLevel);\n    const ll = new Float64Array(size * size);\n    const sorted = new Float64Array(size * size);\n\n    let ptr = 0;\n    let ptrLow = 0;\n    for (let i = 0; i < size; i++) {\n        for (let j = 0; j < size; j++) {\n            ll[ptrLow] = result[ptr];\n            sorted[ptrLow] = result[ptr];\n            ptr += 1;\n            ptrLow += 1;\n        }\n        ptr += imageSize - size;\n    }\n\n    const hash = new Uint8ClampedArray(size * size);\n    const med = median(sorted);\n\n    for (let i = 0; i < hash.length; i++) {\n        hash[i] = ll[i] > med;\n    }\n\n    return new ImageHash(hash)\n}\n","import {canvasUtil, grayScaleConverter} from \"./imageUtils.js\";\nimport {boxBlur} from \"./blur.js\";\nimport {dhash} from \"./dhash.js\";\nimport {ImageMultiHash} from \"./hash.js\";\nimport {createCanvas, ImageData} from \"canvas\";\nimport * as fs from \"fs\";\n\n\nfunction debugSaveImage(pixels, filename, width, height) {\n\n    const rgba = new Uint8ClampedArray(width * height * 4);\n\n    let cur = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const val = pixels[y * height + x]\n            rgba[cur++] = val;\n            rgba[cur++] = val;\n            rgba[cur++] = val;\n            rgba[cur++] = 255;\n        }\n    }\n\n    const canvas = createCanvas(width, height);\n    const ctx = canvas.getContext(\"2d\");\n    const imgData = new ImageData(rgba, width, height);\n    ctx.putImageData(imgData, 0, 0);\n\n    const out = fs.createWriteStream(filename)\n    const stream = canvas.createPNGStream()\n    stream.pipe(out)\n}\n\nfunction findRegion(thresholdPixels, alreadySegmented, size, hill) {\n\n    const region = [];\n    const newPixels = [];\n\n    // Find the first pixel available\n    for (let i = 0; i < thresholdPixels.length; i++) {\n        if (thresholdPixels[i] === hill && alreadySegmented[i] === 0) {\n            region.push(i);\n            newPixels.push(i);\n            alreadySegmented[i] = 1;\n            break;\n        }\n    }\n\n    let top, bottom, left, right, newPixel;\n    while (newPixels.length > 0) {\n        newPixel = newPixels.pop();\n\n        top = newPixel - size;\n        if (top > 0 && thresholdPixels[top] === hill && alreadySegmented[top] === 0) {\n            region.push(top);\n            newPixels.push(top);\n            alreadySegmented[top] = 1;\n        }\n\n        bottom = newPixel + size;\n        if (bottom < thresholdPixels.length && thresholdPixels[bottom] === hill && alreadySegmented[bottom] === 0) {\n            region.push(bottom);\n            newPixels.push(bottom);\n            alreadySegmented[bottom] = 1;\n        }\n\n        left = newPixel - 1;\n        if (newPixel % size !== 0 && thresholdPixels[left] === hill && alreadySegmented[left] === 0) {\n            region.push(left);\n            newPixels.push(left);\n            alreadySegmented[left] = 1;\n        }\n\n        right = newPixel + 1;\n        if (right % size !== 0 && thresholdPixels[right] === hill && alreadySegmented[right] === 0) {\n            region.push(right);\n            newPixels.push(right);\n            alreadySegmented[right] = 1;\n        }\n    }\n\n    return region\n}\n\nfunction findAllSegments(pixels, segImgSize, segThreshold, minSegSize) {\n    let hillCount = 0;\n\n    const thresholdPixels = new Uint8ClampedArray(pixels.length);\n    for (let i = 0; i < pixels.length; i++) {\n        thresholdPixels[i] = pixels[i] > segThreshold;\n        hillCount += pixels[i] > segThreshold;\n    }\n\n    const valleyCount = pixels.length - hillCount;\n\n    const segments = [];\n\n    const alreadySegmented = new Uint8ClampedArray(pixels.length);\n\n    // Find all the \"hill\" regions\n    let segmentedCount = 0;\n    while (segmentedCount < hillCount) {\n        const segment = findRegion(thresholdPixels, alreadySegmented, segImgSize, 1);\n        if (segment.length > minSegSize) {\n            segments.push(segment);\n        }\n        segmentedCount += segment.length;\n    }\n\n    // Find all the \"valley\" regions\n    segmentedCount = 0;\n    while (segmentedCount < valleyCount) {\n        const segment = findRegion(thresholdPixels, alreadySegmented, segImgSize, 0);\n        if (segment.length > minSegSize) {\n            segments.push(segment);\n        }\n        segmentedCount += segment.length;\n    }\n\n    return segments;\n}\n\nexport async function cropResistantHash(image,\n                                        hashFunc = undefined,\n                                        limitSegments = undefined,\n                                        segmentThreshold = 128,\n                                        minSegmentSize = 500,\n                                        segmentationImageSize = 300) {\n\n    if (hashFunc === undefined) {\n        hashFunc = dhash;\n    }\n    const imageWidth = image.naturalWidth || image.width;\n    const imageHeight = image.naturalHeight || image.height;\n\n    segmentationImageSize = Math.min(imageWidth, imageHeight, segmentationImageSize);\n\n    const imageCanvas = canvasUtil.getImageCanvas(image);\n\n    const pixels = grayScaleConverter.convert(await canvasUtil.resizeImageAndGetData(imageCanvas, segmentationImageSize, segmentationImageSize));\n\n    boxBlur(pixels, segmentationImageSize, segmentationImageSize, 4);\n\n    const segments = findAllSegments(pixels, segmentationImageSize, segmentThreshold, minSegmentSize);\n\n    if (limitSegments) {\n        segments.sort((a, b) => b.length - a.length).splice(limitSegments);\n    }\n\n    const scaleW = imageWidth / segmentationImageSize;\n    const scaleH = imageHeight / segmentationImageSize;\n\n    const hashPromises = [];\n\n    for (let i = 0; i < segments.length; i++) {\n        const x = segments[i].map(num => num % segmentationImageSize);\n        const y = segments[i].map(num => num / segmentationImageSize);\n\n        const sx = Math.min(...x);\n        const sy = Math.min(...y);\n        const sw = Math.max(...x) + 1 - sx;\n        const sh = Math.max(...y) + 1 - sy;\n\n        const cropCanvas = canvasUtil.getImageCanvas(\n            canvasUtil.getImageCanvas(image),\n            sx * scaleW, sy * scaleH, sw * scaleW, sh * scaleH\n        );\n        hashPromises.push(hashFunc(cropCanvas));\n    }\n\n    const hashes = await Promise.all(hashPromises);\n\n    return new ImageMultiHash(hashes);\n}","const mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456];\nconst shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16];\n\nclass BlurStack {\n    r = 0;\n    next = null;\n}\n\nexport function boxBlur(pixels, width, height, radius) {\n    const div = 2 * radius + 1;\n\n    const widthMinus1 = width - 1;\n    const heightMinus1 = height - 1;\n    const radiusPlus1 = radius + 1;\n    const sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n    const stackStart = new BlurStack();\n    let stack = stackStart;\n    let stackEnd;\n\n    for (let i = 1; i < div; i++) {\n        stack = stack.next = new BlurStack();\n\n        if (i === radiusPlus1) {\n            stackEnd = stack;\n        }\n    }\n\n    stack.next = stackStart;\n    let stackIn = null;\n    let stackOut = null;\n    const mulSum = mulTable[radius];\n    const shgSum = shgTable[radius];\n    let p;\n    let rbs;\n    let yw = 0;\n    let yi = 0;\n\n    for (let y = 0; y < height; y++) {\n        let pr = pixels[yi],\n            rOutSum = radiusPlus1 * pr,\n            rSum = sumFactor * pr;\n        stack = stackStart;\n\n        for (let _i5 = 0; _i5 < radiusPlus1; _i5++) {\n            stack.r = pr;\n            stack = stack.next;\n        }\n\n        let rInSum = 0;\n\n        for (let _i6 = 1; _i6 < radiusPlus1; _i6++) {\n            rSum += (stack.r = pr = pixels[yi + ((widthMinus1 < _i6 ? widthMinus1 : _i6))]) * (rbs = radiusPlus1 - _i6);\n            rInSum += pr;\n            stack = stack.next;\n        }\n\n        stackIn = stackStart;\n        stackOut = stackEnd;\n\n        for (let x = 0; x < width; x++) {\n            pixels[yi] = rSum * mulSum >> shgSum;\n            rSum -= rOutSum;\n            rOutSum -= stackIn.r;\n            rInSum += stackIn.r = pixels[yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)];\n            rSum += rInSum;\n            stackIn = stackIn.next;\n            rOutSum += pr = stackOut.r;\n            rInSum -= pr;\n            stackOut = stackOut.next;\n            yi += 1;\n        }\n\n        yw += width;\n    }\n\n    for (let _x2 = 0; _x2 < width; _x2++) {\n        yi = _x2;\n\n        let _pr2 = pixels[yi],\n            _rOutSum2 = radiusPlus1 * _pr2,\n            _rSum2 = sumFactor * _pr2,\n\n            stack = stackStart;\n\n        for (let _i7 = 0; _i7 < radiusPlus1; _i7++) {\n            stack.r = _pr2;\n            stack = stack.next;\n        }\n\n        let _rInSum2 = 0;\n\n        for (let _i8 = 1, yp = width; _i8 <= radius; _i8++) {\n            yi = yp + _x2;\n            _rSum2 += (stack.r = _pr2 = pixels[yi]) * (rbs = radiusPlus1 - _i8);\n            _rInSum2 += _pr2;\n            stack = stack.next;\n\n            if (_i8 < heightMinus1) {\n                yp += width;\n            }\n        }\n\n        yi = _x2;\n        stackIn = stackStart;\n        stackOut = stackEnd;\n\n        for (let _y2 = 0; _y2 < height; _y2++) {\n            p = yi;\n            pixels[p] = _rSum2 * mulSum >> shgSum;\n            _rSum2 -= _rOutSum2;\n            _rOutSum2 -= stackIn.r;\n            p = _x2 + ((p = _y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width;\n            _rSum2 += _rInSum2 += stackIn.r = pixels[p];\n            stackIn = stackIn.next;\n            _rOutSum2 += _pr2 = stackOut.r;\n            _rInSum2 -= _pr2;\n            stackOut = stackOut.next;\n            yi += width;\n        }\n    }\n}\n"],"names":[],"version":3,"file":"main.js.map"}